<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="default-src 'self';font-src 'self' data:;img-src 'self' https://* data:;media-src 'self';style-src 'self';frame-src player.vimeo.com https://www.youtube-nocookie.com;connect-src 'self';script-src 'self' 'self'" http-equiv=Content-Security-Policy><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://artsin.github.io name=base><title>ArtSin • Developing a Clang-Based Safe Compiler</title><link title="ArtSin - Atom Feed" href=https://artsin.github.io/atom.xml rel=alternate type=application/atom+xml><link href="https://artsin.github.io/custom_subset.css?h=0b9535a28bc3d5bf2321" rel=stylesheet><link href="https://artsin.github.io/main.css?h=fa464346b37e382872db" rel=stylesheet><meta content="light dark" name=color-scheme><meta content="Due to the use of aggressive optimizations by modern C/C++ compilers that exploit undefined behavior, there is a need for a safe compiler that does not perform such optimizations and prevents developers from using unsafe statements and expressions. Such a safe compiler based on GCC has been developed in ISP RAS, but some developers prefer Clang instead of GCC, which has mainly the same problems of exploiting undefined behavior. This paper examines the capabilities of Clang to perform safe compilation and describes the implementation of a safe compiler based on it. For the created safe compiler, the applicability in practice is shown and the impact on program performance is evaluated." name=description><meta content="Due to the use of aggressive optimizations by modern C/C++ compilers that exploit undefined behavior, there is a need for a safe compiler that does not perform such optimizations and prevents developers from using unsafe statements and expressions. Such a safe compiler based on GCC has been developed in ISP RAS, but some developers prefer Clang instead of GCC, which has mainly the same problems of exploiting undefined behavior. This paper examines the capabilities of Clang to perform safe compilation and describes the implementation of a safe compiler based on it. For the created safe compiler, the applicability in practice is shown and the impact on program performance is evaluated." property=og:description><meta content="Developing a Clang-Based Safe Compiler" property=og:title><meta content=article property=og:type><meta content=en_GB property=og:locale><meta content=https://artsin.github.io/blog/safelang/ property=og:url><meta content=ArtSin property=og:site_name><noscript><link href=https://artsin.github.io/no_js.css rel=stylesheet></noscript><script src=https://artsin.github.io/js/initializeTheme.min.js></script><script defer src=https://artsin.github.io/js/themeSwitcher.min.js></script><script src="https://artsin.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><header><nav class=navbar><div class=nav-title><a class=home-title href=https://artsin.github.io>ArtSin</a></div><div class=nav-navs><ul><li><a class="nav-links no-hover-padding" href=https://artsin.github.io/blog/>blog </a><li><a class="nav-links no-hover-padding" href=https://artsin.github.io/archive/>archive </a><li><a class="nav-links no-hover-padding" href=https://artsin.github.io/tags/>tags </a><li class=menu-icons-container><ul class=menu-icons-group><li class="js menu-icon"><div aria-label="Click or press $SHORTCUT to open search" class="search-icon interactive-icon" title="Click or press $SHORTCUT to open search" id=search-button role=button tabindex=0><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="M784-120 532-372q-30 24-69 38t-83 14q-109 0-184.5-75.5T120-580q0-109 75.5-184.5T380-840q109 0 184.5 75.5T640-580q0 44-14 83t-38 69l252 252-56 56ZM380-400q75 0 127.5-52.5T560-580q0-75-52.5-127.5T380-760q-75 0-127.5 52.5T200-580q0 75 52.5 127.5T380-400Z"/></svg></div><li class="theme-switcher-wrapper js"><div aria-label="Toggle dark mode" title="Toggle dark/light mode" aria-pressed=false class=theme-switcher role=button tabindex=0></div><div aria-label="Reset mode to default" class="theme-resetter arrow" title="Reset mode to default" aria-hidden=true role=button tabindex=0></div></ul></ul></div></nav></header><div class=content><main><article><h1 class=article-title>Developing a Clang-Based Safe Compiler</h1><ul class=meta><li>22nd Dec 2024<li title="5009 words"><span aria-hidden=true class=separator>•</span>26 min read<li class=tag><span aria-hidden=true class=separator>•</span>Tags: <li class=tag><a href=https://artsin.github.io/tags/compiler/>compiler</a>, <li class=tag><a href=https://artsin.github.io/tags/vulnerability/>vulnerability</a>, <li class=tag><a href=https://artsin.github.io/tags/undefined-behavior/>undefined behavior</a>, <li class=tag><a href=https://artsin.github.io/tags/clang/>clang</a>, <li class=tag><a href=https://artsin.github.io/tags/llvm/>llvm</a>, <li class=tag><a href=https://artsin.github.io/tags/c/>c</a>, <li class=tag><a href=https://artsin.github.io/tags/c/>c++</a></ul><section class=body><p>P.D. Dunaev, A.A. Sinkevich, A.M. Granat, I.A. Batraeva, S.V. Mironov, N.U. Shugaley<p>Citation info and full text in Russian: <a href=https://doi.org/10.15514/ISPRAS-2024-36(4)-3>https://doi.org/10.15514/ISPRAS-2024-36(4)-3</a><details><summary>Updates from the original paper</summary> <ul><li>Added <code>-fkeep-div-by-zero</code>;<li>Added <code>-finbounds-aliasing</code>;<li>Updated <code>_FORTIFY_SOURCE</code> — <code>-D_FORTIFY_SOURCE=3</code> is used for all safety classes;<li>Updated Alpine Linux build results and added package bug fixes.</ul></details><p><strong>Abstract</strong>: Due to the use of aggressive optimizations by modern C/C++ compilers that exploit undefined behavior, there is a need for a safe compiler that does not perform such optimizations and prevents developers from using unsafe statements and expressions. Such a safe compiler based on GCC has been developed in ISP RAS, but some developers prefer Clang instead of GCC, which has mainly the same problems of exploiting undefined behavior. This paper examines the capabilities of Clang to perform safe compilation and describes the implementation of a safe compiler based on it. For the created safe compiler, the applicability in practice is shown and the impact on program performance is evaluated.<h2 id=1-introduction>1. Introduction</h2><p>Recently, Clang <sup class=footnote-reference id=fr-1-1><a href=#fn-1>1</a></sup> has gained great popularity as a C++ compiler. According to JetBrains statistics <sup class=footnote-reference id=fr-2-1><a href=#fn-2>2</a></sup>, more than a third of respondents used the compiler in 2023, characterizing it as the second most popular C++ compiler. Clang has certain advantages over competing developments, including the most popular compiler — GCC <sup class=footnote-reference id=fr-3-1><a href=#fn-3>3</a></sup>. Among these advantages is the Apache 2.0-based license <sup class=footnote-reference id=fr-4-1><a href=#fn-4>4</a></sup>, which allows the compiler code to be used for projects under a larger number of licenses. A significant advantage of Clang is also that it is built on top of the LLVM compiler infrastructure <sup class=footnote-reference id=fr-5-1><a href=#fn-5>5</a></sup>, the value of which lies in the fact that compiler tweaks can often focus entirely on transformations of the LLVM IR (intermediate representation), as used, for example, in <sup class=footnote-reference id=fr-6-1><a href=#fn-6>6</a></sup> <sup class=footnote-reference id=fr-7-1><a href=#fn-7>7</a></sup> <sup class=footnote-reference id=fr-8-1><a href=#fn-8>8</a></sup> <sup class=footnote-reference id=fr-9-1><a href=#fn-9>9</a></sup>.<p>However, Clang, like GCC, has a significant drawback — it performs optimizations that take advantage of undefined behavior. For example, the article <sup class=footnote-reference id=fr-10-1><a href=#fn-10>10</a></sup> lists a number of drawbacks, many of which apply to Clang. An example of an optimization performed by the compiler in question is the removal of checks of the form <code>if (1 << X == 0)</code>, where <code>X</code> is an integer. The result of performing this bitwise shift can be zero on some processor architectures, such as PowerPC. But the compiler considers this check redundant because it can prove that this statement is always false in the absence of undefined behavior. However, it is not possible to disable this optimization using options. So when compiling a project with Clang, you need additional protection against programmer and compiler introducing vulnerabilities into the output code.<p>The need to rid the code of vulnerabilities can be met by various methods, such as static and dynamic analysis, extensive testing, and the use of secure coding standards. The authors of the article <sup class=footnote-reference id=fr-11-1><a href=#fn-11>11</a></sup> show that there are situations where none of these methods is applicable to the problem of eliminating vulnerabilities created by the compiler. The authors propose an alternative solution — a safe compiler with built-in functionality that prevents vulnerabilities introduced by aggressive optimizations and warns of vulnerabilities introduced by the programmer. The paper describes a safe compiler based on GCC <sup class=footnote-reference id=fr-12-1><a href=#fn-12>12</a></sup>. However, GCC cannot serve as a replacement for Clang because Clang is not fully compatible with GCC <sup class=footnote-reference id=fr-13-1><a href=#fn-13>13</a></sup>, and due to a number of advantages described above, not all developers will be willing to abandon Clang. Thus, the problem of safe compilation via Clang becomes relevant.<h2 id=2-the-concept-of-a-safe-compiler>2. The concept of a safe compiler</h2><p>The paper <sup class=footnote-reference id=fr-11-2><a href=#fn-11>11</a></sup> describes the concept of a safe compiler. A safe compiler, to be considered as such, must satisfy the following requirements:<ul><li>The compiler cannot introduce vulnerabilities into the generated code during the execution of optimizations;<li>The compiler must not remove code based on the assumption that there is no undefined behavior while not slowing down the output program significantly;<li>The changes required to successfully compile the source code are minimal;<li>The compiler does not provide the ability to partially disable options that control the fulfillment of the first two requirements.</ul><p>Such a compiler can work as a replacement for the previously used one, but besides its main advantage — vulnerability prevention — the compiler will also have disadvantages in the form of slowing down the compiled application and the need to modify the source code, even if minimally, which in some cases may be difficult or impossible.<p>Detailed requirements for a safe compiler are given in the standard <sup class=footnote-reference id=fr-14-1><a href=#fn-14>14</a></sup>. There are three classes of requirements, each characterized by the strictness of the security mechanisms and the speed of the generated programs. The requirements of the standard can be met either by a compiler written from scratch, or by an existing compiler that has been modified or properly configured. Since the target audience of this paper is Clang users, the option of writing a new compiler is not considered; the possibilities of configuring Clang to meet the requirements of a safe compiler are discussed in Section 3, the work done to make Clang a safe compiler is described in Section 4, and the results of testing safe Clang on real applications are presented in Section 5.<h2 id=3-matching-clang-s-features-to-the-requirements-of-a-safe-compiler>3. Matching Clang’s features to the requirements of a safe compiler</h2><p>A class 3 safe compiler should only perform safe transformations of source and machine code. For example, the compiler may convert the condition <code>N + 1 > N</code> to <code>true</code> because it assumes that undefined behavior cannot occur (in this case — integer overflow), and the third class safe compiler must guarantee protection against such transformations. The transformation restriction and the corresponding Clang options are summarized in Table 1.<p>In addition, a compiler of the third security class must include enhanced security mechanisms. The required mechanisms and their corresponding Clang options are listed in Table 2.<p>Also, one of the tasks of the third security class is to issue warnings during the build process in some cases of undefined behavior. The Clang options that include issuing such warnings are shown in Table 3.<div class=table-caption>Table 1. Implementation of class 3 requirements for disabling unsafe transformations in Clang</div><table><thead><tr><th><strong>Paragraph of the standard</strong><th><strong>Requirement</strong><th><strong>Option</strong><tbody><tr><td>5.2.1 а<td>Disable transformations related to integer overflow<td><code>-fwrapv</code><tr><td>5.2.1 б<td>Disable transformations related to the fact that values of pointers of different types may coincide<td><code>-fno-strict-aliasing</code><tr><td>5.2.1 в<td>Disable transformations related to dereferencing of null pointers<td><code>-fno-delete-null-pointer-checks</code><tr><td>5.2.1 г<td>Disable transformations related to division by zero and taking the remainder from division by 0<td>—<tr><td>5.2.1 д<td>Disable transformations related to bitwise shift argument values<td>—</table><div class=table-caption>Table 2. Implementation of class 3 requirements for enabling increased safety mechanisms in Clang</div><table><thead><tr><th><strong>Paragraph of the standard</strong><th><strong>Requirement</strong><th><strong>Option</strong><tbody><tr><td>5.2.2 а<td>Protection against constant size buffer overflow when calling standard library functions<td><code>-D_FORTIFY_SOURCE=2</code> with a caveat: if an error occurs, these functions may output redundant information, although the program should terminate immediately according to the requirements<tr><td>5.2.2 б<td>Stack integrity control mechanism<td><code>-fstack-protector-strong</code><tr><td>5.2.2 в<td>Mechanism of randomization of code placement in the address space<td><code>-fpic/-fPIC/-fPIE</code><tr><td>5.2.2 г,д<td>Prohibition of replacing calls to certain formatted output and memory manipulation functions with equivalent sequences of machine instructions<td><code>-fno-builtin-*</code>, with some functions working with widechar strings having no built-in counterparts in Clang, so this requirement is automatically met for them<tr><td>5.2.6<td>Optional mechanisms (e.g. control flow integrity)<td>There is a solution in the form of <code>-fsanitize=cfi</code>, but it contradicts the logic of the third class, as it can slow down the program significantly</table><div class=table-caption>Table 3. Implementation of class 3 requirements for enabling warnings about unsafe statements in Clang</div><table><thead><tr><th><strong>Paragraph of the standard</strong><th><strong>Requirement</strong><th><strong>Option</strong><tbody><tr><td>5.2.3 а<td>Clobbering of a variable in automatic memory when calling <code>longjmp</code><td>—<tr><td>5.2.3 б<td>Read or write to an array at an invalid index<td><code>-Warray-bounds</code> and <code>-Warray-bounds-pointer-arithmetic</code><tr><td>5.2.3 в<td>Division by zero or taking the remainder from division by 0<td><code>-Wdivision-by-zero</code><tr><td>5.2.3 г<td>Bitwise shift operation with the second argument less than zero or greater than or equal to the width of the type of the first argument<td><code>-Wshift-count-negative</code> and <code>-Wshift-count-overflow</code></table><p>The main goals of a class 2 safe compiler are to prevent vulnerabilities related to incorrect memory handling, and to prevent the use of undefined constructs — the same ones a class 3 compiler warns against — by stopping the compilation with an error. Clang implements only a few of these. A complete list of the requirements and the options by which they are implemented is given in Table 4.<div class=table-caption>Table 4. Implementation of class 2 requirements in Clang</div><table><thead><tr><th><strong>Paragraph of the standard</strong><th><strong>Requirement</strong><th><strong>Option</strong><tbody><tr><td>5.3.1 а<td>Preservation of the side effects of memory writes<td>—<tr><td>5.3.1 б<td>Automatic initialization of variables with zeros<td><code>-ftrivial-auto-var-init=zero</code><tr><td>5.3.1 доп. а<td>Prohibition of bitwise shift optimizations if the second argument can be negative or greater than or equal to the size of the type<td>—<tr><td>5.3.1 доп. б<td>Use of vector instructions that do not require data alignment<td>—<tr><td>5.3.1 доп. в<td>Prohibition of pointer arithmetic optimizations based on object size information<td>—<tr><td>5.3.2 а<td>Compilation failure for class 3 warnings<td><code>-Werror=*</code> instead of <code>-W*</code>, see Table 3<tr><td>5.3.2 б<td>Prohibition of the use of the <code>gets</code> function<td><code>-Werror=deprecated-declarations</code></table><p>One of the main tasks of a safe compiler of the first class is the dynamic control of undefined constructs. In this case, the compiler is required to include machine code in the output file that prevents erroneous execution of undefined constructs during program runtime by crashing the program. This feature is implemented in Clang using the built-in UndefinedBehaviorSanitizer (UBSan) tool <sup class=footnote-reference id=fr-15-1><a href=#fn-15>15</a></sup>, which is used by specifying various options of the form <code>-fsanitize=*</code> in the compilation command line arguments, where <code>*</code> is the identifier of the check for a type of undefined construct. UBSan performs most of the checks that a safe compiler should perform (see Table 5).<div class=table-caption>Table 5. Implementation of class 1 requirements in Clang</div><table><thead><tr><th><strong>Paragraph of the standard</strong><th><strong>Identifier</strong><th><strong>Fulfilled requirement: verifies that…</strong><tbody><tr><td>5.4.3 а<td><code>bool</code><td>The value of <code>bool</code> type variables is <code>0</code> or <code>1</code>.<tr><td>5.4.3 б<td><code>float-cast-overflow</code><td>No overflow occurs when converting a <code>float</code> value to <code>int</code>. However, conversions between floating point types are not checked.<tr><td>5.4.3 в<td><code>shift</code><td>The right operand of the shift is non-negative and less than the width of the type.<tr><td>5.4.3 г<td><code>signed-integer-overflow</code><td>Signed integer overflow does not occur.<tr><td>5.4.3 д<td><code>alignment</code><td>Reads or writes are performed only via pointers whose address is aligned with the size of the operand.<tr><td>5.4.3 е<td><code>null</code><td>Null pointer is not used. However, indirect function call by a null pointer is not checked.<tr><td>5.4.3 ж<td><code>bounds</code><td>Reads or writes are performed at indices that do not extend beyond the array.<tr><td>5.4.3 и<td><code>pointer-overflow</code><td>There is no overflow of the pointer type.<tr><td>5.4.3 к<td><code>function</code><td>In the case of an indirect call, the function signature matches the type of the pointer to it. Works for C++ and x86(-64) only.<tr><td>5.4.3 л<td><code>return</code><td>The function call ends with the <code>return</code> operator. Works only for C++.<tr><td>5.4.3 м<td><code>builtin</code><td>Correct parameters are passed to the built-in functions.<tr><td>5.4.3 н<td><code>unreachable</code><td>Execution does not reach code marked as unreachable.<tr><td>5.4.3 п<td><code>integer-divide-by-zero</code><td>There is no division by zero or taking the remainder from division by zero.<tr><td>5.4.3 р<td><code>vla-bound</code><td>The array allocated in automatic memory has a positive size.</table><p>Another task of a safe compiler is to manage the distribution of automatic and static memory. As part of this task, the first class compiler must support the possibility of dynamic program layout, where functions are arranged in memory in a random order each time the program is launched. If full implementation of this mechanism is impossible (which may be hindered by the dynamic loader) or impractical (as in the case of compiling the operating system kernel), the distribution must be static — unique for each compilation process. Clang does not support static randomized memory distribution, but can support dynamic distribution if the linker and dynamic loader have this feature implemented.<p>It should be noted that a safe compiler of the second class also borrows some of the requirements of the third class, and a compiler of the first class borrows all of the requirements of the second class.<p>Thus, there is no configuration of Clang that satisfies at least one of the safe compilation classes, but the compiler provides a number of features to prevent unsafe optimizations and the execution of unsafe constructs, which can be used in particular when developing a safe compiler based on it.<h2 id=4-safe-compiler-implementation>4. Safe compiler implementation</h2><p>The implemented safe compiler was developed on the basis of Clang 16.0.6. The <code>-Safe3</code>, <code>-Safe2</code>, and <code>-Safe1</code> options were added to include the options of the corresponding safety classes available in Clang and developed in this work. To conveniently manage the functionality of the options, a domain-specific language based on TableGen <sup class=footnote-reference id=fr-16-1><a href=#fn-16>16</a></sup> was developed that describes the inclusion of the options in the following format:<pre class=z-code><code><span class="z-text z-plain">def fno_strict_aliasing : Force<"-fno-strict-aliasing", 1, 3>;
</span><span class="z-text z-plain">def fassume_unaligned : Force<"-fassume-unaligned", 1, 2>;
</span></code></pre><p>The following options have been implemented for 3rd class:<ol><li><code>-fkeep-oversized-shifts</code>: prevents bitwise shift optimization in cases where the second argument of the shift operator is less than zero or greater than or equal to the type width. This option is implemented by replacing the generation of LLVM IR shift instructions with calls to new intrinsic functions. The <code>InstCombine</code> and <code>SCCP</code> passes are supplemented by optimizations of these calls, which are only performed if the compiler can prove that the second argument is non-negative and strictly less than type width. Otherwise, intrinsic function calls are expanded (replaced by the corresponding instructions) after all optimization passes, thus avoiding optimizations.<li><code>-fkeep-div-by-zero</code>: prevents optimization of division and remainder operations in cases where the divisor can be zero. This option is implemented in the same way as <code>-fkeep-oversized-shifts</code>.<li>The headers containing fortified versions of the standard library functions, which are used in Alpine Linux and the SAFEC safe compiler, have been modified to support Clang, and more functions have been added. By using the header files included in the compiler, both the glibc and musl standard libraries are supported. Instead of <code>-D_FORTIFY_SOURCE=2</code>, support for <code>-D_FORTIFY_SOURCE=3</code> has been added, checking not only calls with constant-sized objects, but also with those for which a size expression can be constructed at compile time. Also, these headers have been used to implement immediate program termination on error in fortified functions, to prevent functions from being replaced by Clang built-ins, and to add a warning (an error in <code>-Safe2</code>) when the <code>gets</code> function is used.<li>Instead of warning about clobbering of a variable in automatic memory when <code>longjmp</code> is called, the <code>-fforce-volatile-before-setjmp</code> option was implemented to mark all local variables available at the time <code>setjmp</code> is called as <code>volatile</code>, preventing the compiler from placing these variables in registers and preventing them from being clobbered after <code>longjmp</code> is called. This option is implemented as a pass at the beginning of the optimization pipeline that handles LLVM IR. This pass detects vulnerable variables (allocations on the stack) and marks all instructions that use them as <code>volatile</code>.</ol><p>The following options have been implemented for 2nd class:<ol><li>To preserve the side effects of memory writes, the <code>-fpreserve-memory-writes</code> option has been created which prevents DSE (Dead Store Elimination) in multiple passes of the optimization pipeline. For example, this option preserves the clearing of memory containing sensitive data. In the <code>EarlyCSE</code> pass, which eliminates trivially redundant instructions, the option disables the deletion of consecutive writes to the same memory location without a read in between. In <code>InstCombine</code>, which performs merging and deleting of instructions, a similar optimization is disabled. In the <code>MemCpyOptimizer</code> pass, which optimizes memory manipulation instructions such as <code>memset</code> and <code>memcpy</code>, the merging of overlapping memory writes into a single <code>memset</code> is disabled. Finally, in the <code>DeadStoreElimination</code> pass, which does the main work of optimizing redundant writes, instead of deleting them, the <code>volatile</code> flag is set so that these instructions cannot be optimized by the next passes.<li>The <code>-fassume-unaligned</code> option adds a pass to the beginning of the optimization pipeline that removes alignment from <code>load</code> and <code>store</code> instructions, as well as from pointer arguments in function calls. This results in the generation of unaligned memory instructions instead of vector instructions expecting aligned memory, and prevents program crashes in cases where the used memory section was misaligned.<li>The <code>-finbounds-aliasing</code> option prevents optimizations where the compiler assumes that a pointer that goes beyond the boundaries of the object it points to cannot point to other objects. To accomplish this, <code>BasicAliasAnalysis</code> has been modified so that if there is a <code>getelementptr</code> instruction for which it fails to prove that the result does not extend beyond the boundaries of the object, <code>MayAlias</code> is returned as the result of the aliasing analysis of two objects. Also, in <code>InstCombineLoadStoreAlloca</code>, replacing of the GEP index with 0 in case any other value would be out of bounds is prevented. In <code>SelectionDAGAddressAnalysis</code>, the option prevents pointers from being assumed to be independent of each other if they are derived from different variables. In addition, in <code>ScheduleDAGInstrs</code>, the underlying object identification for a pointer returned by an instruction is disabled (except in the trivial case) to prevent optimization.</ol><p>The following options have been implemented for 1st class:<ol><li>Since the <code>float-cast-overflow</code> check in UndefinedBehaviorSanitizer checks for overflow only when converting from floating-point real types to integer types, the <code>-fsanitize=float-to-float-cast-overflow</code> option has been created to check conversions between real types. The implementation is based on an older version of the <code>float-cast-overflow</code> check, whose behavior was changed in Clang 9 because this type of overflow is defined by IEEE 754 <sup class=footnote-reference id=fr-17-1><a href=#fn-17>17</a></sup>.<li>The <code>-fsanitize=null-call</code> option checks that a null pointer is not used in an indirect function call. This check is absent in <code>-fsanitize=null</code> in UBSan.<li>In Clang 16, the <code>-fsanitize=function</code> option, which checks the correspondence between the formal function type and the actual pointer type, only supports C++ and x86(-64) architecture, so improvements have been ported from Clang 17 to allow its use for C and other architectures. The main change is the use of type hashes instead of RTTI (Run-Time Type Information), which is only available for C++.<li>The built-in <code>-fsanitize=return</code> option checks for the presence of a return operation when exiting a function that has a return value, but only for C++, since in C, using the value returned by such a function is undefined behavior, not the absence of a return. To make the checking behavior uniform, the <code>-fsanitize=return-c</code> option has been implemented, which works the same way for C as for C++.<li>To support the unique distribution of a program’s static memory at compile time, the <code>-frandom-func-reorder</code> and <code>-frandom-func-and-globals-reorder</code> options have been added to shuffle only functions or functions and global variables, respectively, in each compilation unit. These options include a pass at the end of the LLVM IR optimization pipeline that randomizes the order of functions and global variables based on the contents of the module and the number specified by the <code>-mllvm -rng-seed</code> option.<li>For automatic memory randomization, the <code>-floc-var-per</code> option is created, which shuffles local variables (more precisely, constant-sized allocations on the stack) in a random order. This functionality is implemented in the same pass as the previous two options. The <code>-fadd-loc-var</code> option is also supported, which specifies the number of local variables to add during shuffling. Without it, when using <code>-floc-var-per</code>, a small random number of variables will be added to increase the randomness of automatic memory.</ol><h2 id=5-results>5. Results</h2><h3 id=5-1-correctness>5.1. Correctness</h3><p>The developed Clang-based safe compiler successfully passes all tests of a test suite created to verify the correctness of the SAFEC safe compiler <sup class=footnote-reference id=fr-11-3><a href=#fn-11>11</a></sup> and its conformance to the standard. This suite includes tests that check whether the required diagnostics are issued, tests that check whether dynamic checks are triggered at runtime, and tests that check the result of code generation.<h3 id=5-2-performance-study>5.2. Performance study</h3><p>The performance of programs compiled with the safe compiler was evaluated using the same 5 tests as for SAFEC:<ul><li>playing a game of Go using GNU Go 3.8;<li>transcoding files from WAV to MP3 using LAME 3.100;<li>performing the fannkuch test from The Computer Language Benchmarks Game;<li>transcoding files from YUV to MKV using x264 (x264-snapshot-20190407-2245-stable);<li>text file compression using zlib 1.2.11.</ul><div class=table-caption>Table 6. Performance evaluation results</div><table><thead><tr><th><strong>Test</strong><th><strong>Baseline</strong><th><strong><code>-⁠Safe3</code></strong><th><strong><code>-⁠Safe3</code> slowdown</strong><th><strong><code>-⁠Safe2</code></strong><th><strong><code>-⁠Safe2</code> slowdown</strong><th><strong><code>-⁠Safe1</code></strong><th><strong><code>-⁠Safe1</code> slowdown</strong><tbody><tr><td>GNU Go<td>3.93 s<td>4.03 s<td>2.54%<td>4.26 s<td>8.12%<td>6.66 s<td>69.04%<tr><td>LAME<td>5.21 s<td>5.27 s<td>1.15%<td>4.90 s<td>-5.82%<td>13.19 s<td>153.40%<tr><td>fannkuch<td>2.24 s<td>2.10 s<td>-6.25%<td>2.08 s<td>-7.14%<td>2.72 s<td>21.43%<tr><td>x264<td>1.69 s<td>1.81 s<td>7.42%<td>1.79 s<td>5.20%<td>6.32 s<td>274.74%<tr><td>zlib<td>1.54 s<td>1.63 s<td>5.88%<td>1.62 s<td>5.87%<td>2.40 s<td>55.60%</table><p>Table 6 shows the results of measuring the test execution time on a computer with AMD Ryzen™ 5 4600H processor (x86-64 architecture) running Manjaro Linux 23.1.4. The Baseline column corresponds to the compiler run with the <code>-O2</code> option, and the <code>-Safe3</code>, <code>-Safe2</code>, <code>-Safe1</code> columns correspond to runs with the <code>-O2</code> optimization level and the corresponding safety class. Each value is the average of 5 runs, rounded to 0.01 s. The slowdown relative to the baseline time is also given for each safety level.<p>From the data presented, it can be seen that when using the 3rd or 2nd safety class, the slowdown does not exceed 10%, while programs compiled with the 2nd safety level sometimes appear to be faster. This may be due to the fact that in class 2, unlike in class 3, there is no prohibition to replace calls of memory manipulation functions from the standard library with equivalent sequences of machine instructions. When using the 1st class of protection, the slowdown ranges from 21% to 275%, which in the case of x264 exceeds the allowed 200% threshold.<p>The significant slowdown of x264 can be explained by the addition of a large number of pointer overflow checks by the <code>pointer-overflow</code> sanitizer — without it, the slowdown is 165%. It was also found that the baseline version of x264 compiled with Clang was 64% faster than the one compiled with SAFEC 11.4.0, and with safety level 1 the runtimes were about the same, so when comparing safety level 1 of Clang with the base version of GCC the slowdown will be less than 200%.<p>In addition, the tests revealed that the <code>pointer-overflow</code> sanitizer in Clang, unlike GCC and SAFEC based on it, finds an overflow in GNU Go when adding an unsigned integer to a pointer. This is a known limitation of GCC <sup class=footnote-reference id=fr-18-1><a href=#fn-18>18</a></sup>.<h3 id=5-3-building-a-linux-distribution>5.3. Building a Linux distribution</h3><p>In addition to testing several applications individually with safe Clang, the applicability of the safe compiler was evaluated by building a Linux distribution. Alpine Linux 3.20.3 <sup class=footnote-reference id=fr-19-1><a href=#fn-19>19</a></sup>, a lightweight and security-oriented distribution using musl, BusyBox, and OpenRC was chosen for this task. Since the distribution uses GCC for building from source by default, Clang was added as a dependency to the <code>build-base</code> build meta-package and <code>/usr/bin/gcc</code>, <code>/usr/bin/cc</code> and similar files were replaced with symbolic links to Clang. Safe compiler patches have also been added to the <code>clang16</code> and <code>llvm16</code> packages. As a result, every package from the <code>main</code> and <code>community</code> repositories has been built with all safety classes: from unsafe mode to class 1.<div class=table-caption>Table 7. Alpine Linux package build results</div><table><thead><tr><th><strong>Class</strong><th><strong>Successfully built</strong><th><strong>Build or test errors</strong><tbody><tr><td>Baseline<td>3810<td>668<tr><td><code>-Safe3</code><td>3792<td>Build: 13, test: 5<tr><td><code>-Safe2</code><td>3745<td>Build: 44, test: 3<tr><td><code>-Safe1</code><td>3340<td>Build/test: 403, ICE: 2</table><p>Table 7 summarizes for each safety class the number of packages that were successfully built and the number of packages that failed with a build or test error. The large number of packages not built by Clang in insecure mode is in many cases due to Clang’s incompatibility with GCC, as some warnings are set as errors by default, and packages’ use of options present only in GCC. It is also worth noting that almost half of all packages (3574 out of 8052) do not use the C/C++ compiler, or do not take into account the <code>CFLAGS</code>, <code>CXXFLAGS</code> or <code>CPPFLAGS</code> environment variables, through which the <code>-Safe</code> option is passed, so they are not considered in this paper.<p>At safety level 3, only 18 packages could not be built. Of these, 13 are incompatible with the <code>_FORTIFY_SOURCE</code> implementation in safe Clang, e.g. due to function declarations without specifying arguments, or due to trying to set <code>_FORTIFY_SOURCE</code> to 0 when <code>-Werror</code> is present. One package removes the <code>const</code> keyword with <code>#define const</code>, which prevents compilation of fortified function headers. The remaining packages failed the built-in tests, mostly due to triggering fortified functions. Since class 3 warnings become errors in safety class 2, 34 packages failed to compile at this level due to <code>-Warray-bounds-pointer-arithmetic</code>, 4 due to <code>-Warray-bounds</code>, and 6 due to <code>-Wshift-count-overflow</code>.<p>Bug fixes <sup class=footnote-reference id=fr-20-1><a href=#fn-20>20</a></sup> <sup class=footnote-reference id=fr-21-1><a href=#fn-21>21</a></sup> <sup class=footnote-reference id=fr-22-1><a href=#fn-22>22</a></sup> were proposed for 3 packages that failed the tests when built with safety class 3 or 2, of which 1 fix has already been accepted.<p>The 1st safety class includes sanitizers, which caused 400 packages to fail to build. Also, 2 packages failed due to <code>-fsanitize=function</code> incompatibility with WebAssembly. Another package failed due to <code>-Werror=shift-count-overflow</code>. In addition, while building the <code>community/cabextract</code> and <code>community/libu2f-server</code> packages, a bug was discovered in vanilla Clang 16.0.6 that caused the compiler to crash. This has been fixed in Clang 17.<p>In this work it was tested only if the packages of the distribution successfully build and pass the built-in tests, because complete testing of all programs would be too time-consuming. It was shown that 87.6% of packages built by unsafe Clang can be built by the safe version with safety class 1.<h2 id=6-conclusion>6. Conclusion</h2><p>In this work, a safe compiler based on Clang has been implemented. The paper has considered the concept of a safe compiler in relation to the compiler under study. The components that implement the specified features have been highlighted, and the requirements that this compiler does not satisfy have been considered. The decision to develop a safe compiler based on Clang was justified. All the missing components were implemented and described. Using the created safe compiler, it was possible to build most of the packages of the Alpine Linux distribution. It was shown that the performance of the programs built with the safe compiler meets the requirements in almost all cases.<footer class=footnotes><ol class=footnotes-list><li id=fn-1><p>Clang, Available at: <a href=https://clang.llvm.org/>https://clang.llvm.org/</a>, accessed 22.12.2024. <a href=#fr-1-1>↩</a></p><li id=fn-2><p>Jetbrains Developer Ecosystem: C++, Available at: <a href=https://www.jetbrains.com/lp/devecosystem-2023/cpp/>https://www.jetbrains.com/lp/devecosystem-2023/cpp/</a>, accessed 22.12.2024. <a href=#fr-2-1>↩</a></p><li id=fn-3><p>GCC, Available at: <a href=https://gcc.gnu.org/>https://gcc.gnu.org/</a>, accessed 22.12.2024. <a href=#fr-3-1>↩</a></p><li id=fn-4><p>LLVM Developer Policy, Available at: <a href=https://llvm.org/docs/DeveloperPolicy.html>https://llvm.org/docs/DeveloperPolicy.html</a>, accessed 22.12.2024. <a href=#fr-4-1>↩</a></p><li id=fn-5><p>LLVM, Available at: <a href=https://llvm.org/>https://llvm.org/</a>, accessed 22.12.2024. <a href=#fr-5-1>↩</a></p><li id=fn-6><p>Skvortsov L.V., Baev R.V., Dolgorukova K.Y., Sharygin E.Y. Developing an LLVM-based compiler for stack based TF16 processor architecture. Trudy ISP RAN/Proc. ISP RAS, vol. 33, issue 5, 2021, pp. 137-154 (in Russian). DOI: 10.15514/ISPRAS–2021–33(5)–8. <a href=#fr-6-1>↩</a></p><li id=fn-7><p>Melnik D., Kurmangaleev S., Avetisyan A., Belevantsev A., Plotnikov D., Vardanyan M. Optimizing programs for given hardware architectures with static compilation: methods and tools. Trudy ISP RAN/Proc. ISP RAS, vol. 26, issue 1, 2014, pp. 343-356 (in Russian). DOI: 10.15514/ISPRAS-2014-26(1)-13. <a href=#fr-7-1>↩</a></p><li id=fn-8><p>Ivannikov V., Kurmangaleev S., Belevantsev A., Nurmukhametov A., Savchenko V., Matevosyan H., Avetisyan A. Implementing Obfuscating Transformations in the LLVM Compiler Infrastructure. Trudy ISP RAN/Proc. ISP RAS, vol. 26, issue 1, 2014, pp. 327-342 (in Russian). DOI: 10.15514/ISPRAS-2014-26(1)-12. <a href=#fr-8-1>↩</a></p><li id=fn-9><p>Gaissaryan S., Kurmangaleev S., Dolgorukova K., Savchenko V., Sargsyan S. Applying two-stage LLVM-based compilation approach to application deployment via cloud storage. Trudy ISP RAN/Proc. ISP RAS, vol. 26, issue 1, 2014, pp. 315-326 (in Russian). DOI: 10.15514/ISPRAS-2014-26(1)-11. <a href=#fr-9-1>↩</a></p><li id=fn-10><p>Wang X., Chen H. et al. Undefined behavior: what happened to my code? In Proc. of the Asia-Pacific Workshop on Systems, 2012, pp. 1-7. <a href=#fr-10-1>↩</a></p><li id=fn-11><p>Baev R.V., Skvortsov L.V., Kudryashov E.A., Buchatskiy R.A., Zhuykov R.A. Prevention of vulnerabilities arising from optimization of code with Undefined Behavior. Trudy ISP RAN/Proc. ISP RAS, vol. 33, issue 4, 2021. pp. 195-210 (in Russian). DOI: 10.15514/ISPRAS–2021–33(4)–14. <a href=#fr-11-1>↩</a> <a href=#fr-11-2>↩2</a> <a href=#fr-11-3>↩3</a></p><li id=fn-12><p>Safe compiler SAFEC. Available at: <a href=https://www.ispras.ru/technologies/safecomp/>https://www.ispras.ru/technologies/safecomp/</a> (in Russian), accessed 22.12.2024. <a href=#fr-12-1>↩</a></p><li id=fn-13><p>Clang: Language Compatibility, Available at: <a href=https://clang.llvm.org/compatibility.html>https://clang.llvm.org/compatibility.html</a>, accessed 22.12.2024. <a href=#fr-13-1>↩</a></p><li id=fn-14><p>GOST R 71206-2024 «Information protection. Secure software development. Safe C/C++ compiler. General requirements». Moscow, Russian Standardization Institute, 2024, 20 p. (in Russian) <a href=#fr-14-1>↩</a></p><li id=fn-15><p>UndefinedBehaviorSanitizer, Available at: <a href=https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html>https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html</a>, accessed 22.12.2024. <a href=#fr-15-1>↩</a></p><li id=fn-16><p>TableGen Overview, Available at: <a href=https://llvm.org/docs/TableGen/>https://llvm.org/docs/TableGen/</a>, accessed 22.12.2024. <a href=#fr-16-1>↩</a></p><li id=fn-17><p>IEEE 754-2019, Standard for Floating-Point Arithmetic, 2019. pp. 1-84. DOI: 10.1109/IEEESTD.2019.8766229. <a href=#fr-17-1>↩</a></p><li id=fn-18><p>Missing pointer overflow detection with -fsanitize=pointer-overflow, Available at: <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=82079">https://gcc.gnu.org/bugzilla/show_bug.cgi?id=82079</a>, accessed 22.12.2024. <a href=#fr-18-1>↩</a></p><li id=fn-19><p>Alpine Linux, Available at: <a href=https://www.alpinelinux.org/>https://www.alpinelinux.org/</a>, accessed 22.12.2024. <a href=#fr-19-1>↩</a></p><li id=fn-20><p>ngspice / Patches / #119 Fix buffer overflow in src/xspice/icm/digital/d_state/cfunc.mod, Available at: <a href=https://sourceforge.net/p/ngspice/patches/119/>https://sourceforge.net/p/ngspice/patches/119/</a>, accessed 22.12.2024. <a href=#fr-20-1>↩</a></p><li id=fn-21><p>Fix test runner constructors order and <code>_FORTIFY_SOURCE</code> failure by ArtSin · Pull Request #729 · canonical/dqlite, Available at: <a href=https://github.com/canonical/dqlite/pull/729>https://github.com/canonical/dqlite/pull/729</a>, accessed 22.12.2024. <a href=#fr-21-1>↩</a></p><li id=fn-22><p>69482 – teststr segfaults if built with -ftrivial-auto-var-init=zero, Available at: <a href="https://bz.apache.org/bugzilla/show_bug.cgi?id=69482">https://bz.apache.org/bugzilla/show_bug.cgi?id=69482</a>, accessed 22.12.2024. <a href=#fr-22-1>↩</a></p></ol></footer></section></article></main><div id=button-container><div id=toc-floating-container><input class=toggle id=toc-toggle type=checkbox><label class=overlay for=toc-toggle></label><label title="Toggle Table of Contents" class=button for=toc-toggle id=toc-button><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="M414.82-193.094q-18.044 0-30.497-12.32-12.453-12.319-12.453-30.036t12.453-30.086q12.453-12.37 30.497-12.37h392.767q17.237 0 29.927 12.487 12.69 12.486 12.69 30.203 0 17.716-12.69 29.919t-29.927 12.203H414.82Zm0-244.833q-18.044 0-30.497-12.487Q371.87-462.9 371.87-480.45t12.453-29.92q12.453-12.369 30.497-12.369h392.767q17.237 0 29.927 12.511 12.69 12.512 12.69 29.845 0 17.716-12.69 30.086-12.69 12.37-29.927 12.37H414.82Zm0-245.167q-18.044 0-30.497-12.32t-12.453-30.037q0-17.716 12.453-30.086 12.453-12.369 30.497-12.369h392.767q17.237 0 29.927 12.486 12.69 12.487 12.69 30.203 0 17.717-12.69 29.92-12.69 12.203-29.927 12.203H414.82ZM189.379-156.681q-32.652 0-55.878-22.829t-23.226-55.731q0-32.549 23.15-55.647 23.151-23.097 55.95-23.097 32.799 0 55.313 23.484 22.515 23.484 22.515 56.246 0 32.212-22.861 54.893-22.861 22.681-54.963 22.681Zm0-245.167q-32.652 0-55.878-23.134-23.226-23.135-23.226-55.623 0-32.487 23.467-55.517t56.12-23.03q32.102 0 54.721 23.288 22.62 23.288 22.62 55.775 0 32.488-22.861 55.364-22.861 22.877-54.963 22.877Zm-.82-244.833q-32.224 0-55.254-23.288-23.03-23.289-23.03-55.623 0-32.333 23.271-55.364 23.272-23.03 55.495-23.03 32.224 0 55.193 23.288 22.969 23.289 22.969 55.622 0 32.334-23.21 55.364-23.21 23.031-55.434 23.031Z"/></svg></label><div class=toc-content><div class=toc-container><ul><li><a href=https://artsin.github.io/blog/safelang/#1-introduction>1. Introduction</a><li><a href=https://artsin.github.io/blog/safelang/#2-the-concept-of-a-safe-compiler>2. The concept of a safe compiler</a><li><a href=https://artsin.github.io/blog/safelang/#3-matching-clang-s-features-to-the-requirements-of-a-safe-compiler>3. Matching Clang’s features to the requirements of a safe compiler</a><li><a href=https://artsin.github.io/blog/safelang/#4-safe-compiler-implementation>4. Safe compiler implementation</a><li><a href=https://artsin.github.io/blog/safelang/#5-results>5. Results</a> <ul><li><a href=https://artsin.github.io/blog/safelang/#5-1-correctness>5.1. Correctness</a><li><a href=https://artsin.github.io/blog/safelang/#5-2-performance-study>5.2. Performance study</a><li><a href=https://artsin.github.io/blog/safelang/#5-3-building-a-linux-distribution>5.3. Building a Linux distribution</a></ul><li><a href=https://artsin.github.io/blog/safelang/#6-conclusion>6. Conclusion</a></ul></div></div></div><a title="Go to the top of the page" class=no-hover-padding href=# id=top-button> <svg viewbox="0 0 20 20" fill=currentColor><path d="M3.293 9.707a1 1 0 010-1.414l6-6a1 1 0 011.414 0l6 6a1 1 0 01-1.414 1.414L11 5.414V17a1 1 0 11-2 0V5.414L4.707 9.707a1 1 0 01-1.414 0z"/></svg> </a></div><span class=hidden id=copy-success> Copied! </span><span class=hidden id=copy-init> Copy code to clipboard </span><script defer src=https://artsin.github.io/js/copyCodeToClipboard.min.js></script></div><footer><section><nav class="socials nav-navs"><ul><li><a class="nav-links no-hover-padding social" href=https://artsin.github.io/atom.xml> <img alt=feed loading=lazy src=https://artsin.github.io/social_icons/rss.svg title=feed> </a><li><a class="nav-links no-hover-padding social" rel=" me" href=https://github.com/ArtSin> <img alt=github loading=lazy src=https://artsin.github.io/social_icons/github.svg title=github> </a></ul></nav><nav class=nav-navs></nav><div class=credits><small> Powered by <a href=https://www.getzola.org>Zola</a> & <a href=https://github.com/welpo/tabi>tabi</a> </small></div></section><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><h1 class=visually-hidden id=modalTitle>Search</h1><div id=modal-content><div id=searchBar><div aria-hidden=true class=search-icon><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="M784-120 532-372q-30 24-69 38t-83 14q-109 0-184.5-75.5T120-580q0-109 75.5-184.5T380-840q109 0 184.5 75.5T640-580q0 44-14 83t-38 69l252 252-56 56ZM380-400q75 0 127.5-52.5T560-580q0-75-52.5-127.5T380-760q-75 0-127.5 52.5T200-580q0 75 52.5 127.5T380-400Z"/></svg></div><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search… role=combobox spellcheck=false><div class="close-icon interactive-icon" title="Clear search" id=clear-search role=button tabindex=0><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></div></div><div id=results-container><div id=results-info><span id=zero_results> No results</span><span id=one_results> $NUMBER result</span><span id=many_results> $NUMBER results</span><span id=two_results> $NUMBER results</span><span id=few_results> $NUMBER results</span></div><div id=results role=listbox></div></div></div></div></footer>